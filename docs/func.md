## 函数式组件报错

回顾一下报错

![](https://tva1.sinaimg.cn/large/008i3skNgy1grgrurv3vcj31ki0ba430.jpg)

Vue-i18n 源码中的function 如下：

```js
render: function render (h, ref) {
  // ...
  var children = $i18n.i(
    path,
    locale,
    onlyHasDefaultPlace(params) || places
    ? useLegacyPlaces(params.default, places)
    : params
  );

  var tag = props.tag || 'span'; // children 有可能是 String 类型
  return tag ? h(tag, data, children) : children
}
```

关键是调用 `h(tag, data, children)` 做了哪些事情呢？

## Vue 源码分析

![image-20210613173508438](https://tva1.sinaimg.cn/large/008i3skNgy1grgrvkhubjj312e0aatbp.jpg)



调用 `createElement` 方法

调用` _createElement` 方法



![](https://tva1.sinaimg.cn/large/008i3skNgy1grgrwtrze0j30ts17an7e.jpg)

关注这两个参数。normalizationType,alwaysNormalize

![image-20210613173808801](https://tva1.sinaimg.cn/large/008i3skNgy1grgryq5of6j31280iwdnd.jpg)

因为这两个参数值不对，导致最后的值 children 不是 vnode

假如是正确的话，会调用如下的方法：

```js
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}
```

会去判断相关的类型，比如 textNode，会调用 createTextVNode

```js
function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}
```





![image-20210613173928877](https://tva1.sinaimg.cn/large/008i3skNgy1grgs03r8gcj30ze0j443m.jpg)



![image-20210613174035733](https://tva1.sinaimg.cn/large/008i3skNgy1grgs1akwguj31qc0jegw0.jpg)

那 alwaysNormalize 在哪设置的呢？找到设置的点，是 needNormalization

```js
this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
```

needNormalization 是由 needNormalization 决定的...

```js
var isCompiled = isTrue(options._compiled); // true
var needNormalization = !isCompiled; // false
```

假如我手动修改 needNormalization 为 true，就没有问题了



但是这里这个 _compiled 没找到是在哪设置的...【查找了一下资料，说是在 vue-loader 中设置的】

https://github.com/bootstrap-vue/bootstrap-vue/issues/6223

## 结论

- VNode 的 Children 最后肯定是 Vnode
- render function 之所以可以写 String，是因为有像类似 `normalizeChildren` 和 `simpleNormalizeChildren`函数将其转化
- 尽量不要在函数式组件 render 返回中使用 string
- 函数式组件的转换与否，靠 `options._compiled` ，这个目前的定位是在 Vue-Loader 中实现的【源码中修改了，无效，需打一个问题】



